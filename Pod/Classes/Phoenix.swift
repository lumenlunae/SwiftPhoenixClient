////  Phoenix.swift//  SwiftPhoenix////  Created by David Stump on 12/1/14.//  Copyright (c) 2014 David Stump. All rights reserved.//import Foundationimport Starscreampublic struct Phoenix {    // MARK: Phoenix Message  open class Message: NSObject {    var subject: String?    var body: [String: Any]?    open var message: AnyObject?    open var data: [String: Any]?    /**     Initializes single entry message with a subject          - parameter subject: String for message key     - parameter body:    String for message body          - returns: Phoenix.Message     */    public init(subject: String, body: [String: Any]) {      (self.subject, self.body) = (subject, body)      super.init()      self.data = create()    }        /**     Initializes a multi key message          - parameter message: Dictionary containing message payload          - returns: Phoenix.Message     */    public init(message: AnyObject) {      self.message = message      super.init()      self.data = create(false)    }        /**     Creates a new single or multi key message          - parameter single: Boolean indicating if the message is a single key or not          - returns: Phoenix.Message     */    func create(_ single: Bool = true) -> [String: Any] {      if single {        return [self.subject!: self.body!]      } else {        return self.message! as! [String: Any]      }    }  }    // MARK: Phoenix Binding  class Binding {    var event: String    var callback: (AnyObject) -> Void?        /**     Initializes an object for handling event/callback bindings          - parameter event:    String indicating event name     - parameter callback: Function to run on given event          - returns: Tuple containing event and callback function     */    init(event: String, callback: @escaping (AnyObject) -> Void?) {      (self.event, self.callback) = (event, callback)      create()    }        /**     Creates a Phoenix.Binding object holding event/callback details          - returns: Tuple containing event and callback function     */    func create() -> (String, (AnyObject) -> Void?) {      return (event, callback)    }  }    // MARK: Phoenix Channel  open class Channel {    var bindings: [Phoenix.Binding] = []    open var topic: String?    var message: Phoenix.Message?    var callback: ((AnyObject) -> Void?)    weak var socket: Phoenix.Socket?        /**     Initializes a new Phoenix.Channel mapping to a server-side channel          - parameter topic:    String topic for given channel     - parameter message:  Phoenix.Message object containing message to send     - parameter callback: Function to pass along with the channel instance     - parameter socket:   Phoenix.Socket for websocket connection          - returns: Phoenix.Channel     */    init(topic: String, message: Phoenix.Message, callback: ((AnyObject) -> Void), socket: Phoenix.Socket) {      (self.topic, self.message, self.callback, self.socket) = (topic, message, { callback($0) }, socket)      reset()    }        /**     Removes existing bindings     */    func reset() {      bindings = []    }        /**     Assigns Binding events to the channel bindings array          - parameter event:    String event name     - parameter callback: Function to run on event     */    open func on(_ event: String, callback: ((AnyObject) -> Void)) {      bindings.append(Phoenix.Binding(event: event, callback: { callback($0) }))    }        /**     Determine if a topic belongs in this channel          - parameter topic: String topic name for comparison          - returns: Boolean     */    func isMember(topic: String) -> Bool {      return self.topic == topic    }        /**     Removes an event binding from this cahnnel          - parameter event: String event name     */    func off(_ event: String) {      var newBindings: [Phoenix.Binding] = []      for binding in bindings {        if binding.event != event {          newBindings.append(Phoenix.Binding(event: binding.event, callback: binding.callback))        }      }      bindings = newBindings    }        /**     Triggers an event on this channel          - parameter triggerEvent: String event name     - parameter msg:          Phoenix.Message to pass into event callback     */    func trigger(_ triggerEvent: String, msg: Phoenix.Message) {      for binding in bindings {        if binding.event == triggerEvent {          binding.callback(msg)        }      }    }        /**     Sends and event and message through the socket          - parameter event:   String event name     - parameter message: Phoenix.Message payload     */    func send(_ event: String, message: Phoenix.Message) {      print("conn sending")      let payload = Phoenix.Payload(topic: topic!, event: event, message: message)      socket?.send(payload)    }        /**     Leaves the socket          - parameter message: Phoenix.Message to pass to the Socket#leave function     */    func leave(_ message: Phoenix.Message) {      if let sock = socket {        sock.leave(topic: topic!, message: message)      }      reset()    }  }    // MARK: Phoenix Payload  open class Payload {    var topic: String    var event: String    var message: Phoenix.Message        /**     Initializes a formatted Phoenix.Payload          - parameter topic:   String topic name     - parameter event:   String event name     - parameter message: Phoenix.Message payload          - returns: Phoenix.Payload     */    public init(topic: String, event: String, message: Phoenix.Message) {      (self.topic, self.event, self.message) = (topic, event, message)    }      }    // MARK: Phoenix Socket  open class Socket: NSObject, WebSocketDelegate {    var conn: WebSocket?    var endPoint: String?    var channels: [Phoenix.Channel] = []        var sendBuffer: [Void] = []    var sendBufferTimer = Timer()    let flushEveryMs = 1.0        var reconnectTimer = Timer()    let reconnectAfterMs = 1.0        var heartbeatTimer = Timer()    let heartbeatDelay = 30.0        var messageReference: UInt64 = UInt64.min // 0 (max: 18,446,744,073,709,551,615)        /**     Initializes a Socket connection          - parameter domainAndPort: Phoenix server root path and proper port     - parameter path:          Websocket path on Phoenix Server     - parameter transport:     Transport for Phoenix.Server - traditionally "websocket"     - parameter prot:          Connection protocol - default is HTTP          - returns: Phoenix.Socket     */    public init(domainAndPort:String, path:String, query:[String:String] = [:], transport:String, prot:String = "http") {      var query = query, prot = prot      self.endPoint = Path.endpointWithProtocol(prot, domainAndPort: domainAndPort, path: path, query: query, transport: transport)      super.init()      resetBufferTimer()      reconnect()    }        /**     Closes socket connection          - parameter callback: Function to run after close     */    open func close(_ callback: (() -> ()) = {}) {      if let connection = self.conn {        connection.delegate = nil        connection.disconnect()      }      invalidateTimers()      callback()    }        /**     Invalidate open timers to allow socket to be deallocated when closed     */    func invalidateTimers() {      heartbeatTimer.invalidate()      reconnectTimer.invalidate()      sendBufferTimer.invalidate()            heartbeatTimer = Timer()      reconnectTimer = Timer()      sendBufferTimer = Timer()    }        /**     Initializes a 30s timer to let Phoenix know this device is still alive     */    func startHeartbeatTimer() {      heartbeatTimer.invalidate()      heartbeatTimer = Timer.scheduledTimer(timeInterval: heartbeatDelay, target: self, selector: #selector(Phoenix.Socket.heartbeat), userInfo: nil, repeats: true)    }        /**     Heartbeat payload (Phoenix.Message) to send with each pulse     */    func heartbeat() {      let message = Phoenix.Message(message: ["body": "Pong"] as AnyObject)      let payload = Phoenix.Payload(topic: "phoenix", event: "heartbeat", message: message)      send(payload)    }        /**     Reconnects to a closed socket connection     */    open func reconnect() {      close() {        self.conn = WebSocket(url: URL(string: self.endPoint!)!)        if let connection = self.conn {          connection.delegate = self          connection.connect()        }      }    }        /**     Resets the message buffer timer and invalidates any existing ones     */    func resetBufferTimer() {      sendBufferTimer.invalidate()      sendBufferTimer = Timer.scheduledTimer(timeInterval: flushEveryMs, target: self, selector: #selector(Phoenix.Socket.flushSendBuffer), userInfo: nil, repeats: true)      sendBufferTimer.fire()    }        /**     Kills reconnect timer and joins all open channels     */    func onOpen() {      reconnectTimer.invalidate()      startHeartbeatTimer()      rejoinAll()    }        /**     Starts reconnect timer onClose          - parameter event: String event name     */    func onClose(_ event: String) {      reconnectTimer.invalidate()      reconnectTimer = Timer.scheduledTimer(timeInterval: reconnectAfterMs, target: self, selector: #selector(Phoenix.Socket.reconnect), userInfo: nil, repeats: true)    }        /**     Triggers error event          - parameter error: NSError     */    func onError(_ error: NSError) {      print("Error: \(error)")      for chan in channels {        let msg = Phoenix.Message(message: ["body": error.localizedDescription] as AnyObject)        chan.trigger("error", msg: msg)      }    }        /**     Indicates if connection is established          - returns: Bool     */    func isConnected() -> Bool {      if let connection = self.conn {        return connection.isConnected      } else {        return false      }          }        /**     Rejoins all Phoenix.Channel instances     */    func rejoinAll() {      for chan in channels {        rejoin(chan as Phoenix.Channel)      }    }        /**     Rejoins a given Phoenix Channel          - parameter chan: Phoenix.Channel     */    func rejoin(_ chan: Phoenix.Channel) {      chan.reset()      if let topic = chan.topic, let joinMessage = chan.message {        let payload = Phoenix.Payload(topic: topic, event: "phx_join", message: joinMessage)        send(payload)        chan.callback(chan)      }    }        /**     Joins socket          - parameter topic:    String topic name     - parameter message:  Phoenix.Message payload     - parameter callback: Function to trigger after join     */    open func join(topic: String, message: Phoenix.Message, callback: ((AnyObject) -> Void)) {      let chan = Phoenix.Channel(topic: topic, message: message, callback: callback, socket: self)      channels.append(chan)      if isConnected() {        print("joining")        rejoin(chan)      }    }        /**     Leave open socket          - parameter topic:   String topic name     - parameter message: Phoenix.Message payload     */    open func leave(topic: String, message: Phoenix.Message) {      let payload = Phoenix.Payload(topic: topic, event: "phx_leave", message: message)      send(payload)      var newChannels: [Phoenix.Channel] = []      for chan in channels {        let c = chan as Phoenix.Channel        if !c.isMember(topic: topic) {          newChannels.append(c)        }      }      channels = newChannels    }        /**     Send payload over open socket          - parameter data: Phoenix.Payload     */    open func send(_ data: Phoenix.Payload) {      let callback = {        (payload: Phoenix.Payload) -> Void in        if let connection = self.conn {          let json = self.payloadToJson(payload)          print("json: \(json)")          connection.write(string:json)        }      }      if isConnected() {        callback(data)      } else {        sendBuffer.append(callback(data))      }    }        /**     Flush message buffer     */    func flushSendBuffer() {      if isConnected() && sendBuffer.count > 0 {        for callback in sendBuffer {          callback        }        sendBuffer = []        resetBufferTimer()      }    }        /**     Trigger event on message received          - parameter payload: Phoenix.Payload     */    func onMessage(_ payload: Phoenix.Payload) {      let (topic, event, message) = (payload.topic, payload.event, payload.message)      for chan in channels {        if chan.isMember(topic: topic) {          chan.trigger(event, msg: message)        }      }    }        // WebSocket Delegate Methods    open func websocketDidReceiveMessage(_ socket: WebSocket, text: String) {      print("socket message: \(text)")      let jsonData: Data = text.data(using: .utf8)!      let json: AnyObject = try! JSONSerialization.jsonObject(with: jsonData) as AnyObject            let (topic, event) = (        unwrappedJsonString(json["topic"] as! String),        unwrappedJsonString(json["event"] as! String)      )      let msg: [String: AnyObject] = json["payload"] as! [String: AnyObject]            let messagePayload = Phoenix.Payload(topic: topic, event: event, message: Phoenix.Message(message: msg as AnyObject))      onMessage(messagePayload)    }        open func websocketDidReceiveData(_ socket: WebSocket, data: Data) {      print("got some data: \(data.count)")    }        open func websocketDidDisconnect(_ socket: WebSocket, error: NSError?) {      if let err = error { onError(err) }      print("socket closed: \(error?.localizedDescription)")      onClose("reason: \(error?.localizedDescription)")    }        open func websocketDidConnect(_ socket: WebSocket) {      print("socket opened")      onOpen()    }        open func websocketDidWriteError(_ error: NSError?) {      onError(error!)    }        func unwrappedJsonString(_ string: String?) -> String {      if let stringVal = string {        return stringVal      } else {        return ""      }    }        func makeRef() -> UInt64 {      let newRef = messageReference + 1      messageReference = (newRef == UINT64_MAX) ? 0 : newRef      return newRef    }        func payloadToJson(_ payload: Phoenix.Payload) -> String {      let ref = Int(makeRef())      var params = ["topic": payload.topic, "event": payload.event, "ref": ref, "payload": payload.message.data!] as [String : Any]            let options = JSONSerialization.WritingOptions()      let data = try! JSONSerialization.data(withJSONObject: params, options: options)      let serialized = String(data: data, encoding: .utf8)!            return serialized          }  }}